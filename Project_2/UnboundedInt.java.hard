
public class UnboundedInt {
    int sign, numNodes;
    IntNode head, tail, cursor;

    public UnboundedInt(String input) {
        // sanitize input String to avoid NumberFormatException

        // assume sign is positive
        this.sign = 1;

        // start with no linked list
        this.head = null;

        // check if negative sign at start of input, set sign accordingly
        if (input.charAt(0) == '-')
            this.sign = -1;

        // use regex to remove all non-digits from input
        // (no scientific notation, kthxbai)
        input = input.replaceAll("[^\\d]+", "");

        int len = input.length();

        // if the string is empty, then no digits were in the input
        if (len == 0)
            throw new NumberFormatException("String must contain one or more digits");

        // each node contains a 3-digit number 0-999:
        // if we take the input string's length, divide by 3,
        // and ceil the result, that will give us the number of nodes needed
        this.numNodes = (int)Math.ceil(((double)len)/3);
        String nodeStr;
        int nodeInt;
        int n = 0;
        IntNode prevNode = null;
        IntNode newNode = null;

        // now we need to loop through the input string BACKWARDS
        // this is because the ones place starts at the end of the string (rightmost char)
        // reverse the input string for traversal
        //System.out.format("Original input: %s\n", input);
        input = new StringBuilder(input).reverse().toString();
        //System.out.format("Reversed input: %s\n", input);

        // traverse the reversed string and create nodes with each group of 3 digits/chars
        // create the linked list in reverse order, starting from the tail
        for (int i=0; i<len; i+=3) {
            // create a char[] to hold this node's value in string format, default=000
            char[] digit = {'0', '0', '0'};

            for (int j=0; j<3; j++) {
                int k = i+j;
                if (k >= len)
                    break;
                digit[2-j] = input.charAt(k);
                //System.out.format("2-j = %d: %s %s %s\n", 2-j, digit[0], digit[1], digit[2]);
            }

            // create a string from the char[]
            nodeStr = new String(digit);
            // parse the integer value from the string
            nodeInt = Integer.parseInt(nodeStr);
            // finally, create a node using the parsed integer value
            newNode = new IntNode(nodeInt, null);

            if (prevNode == null) {
                // if this is the first node we're creating (prevNode null)
                // then maintain a reference to this newNode as the tail
                this.tail = newNode;
            } else {
                // otherwise set this newNode to point to the prevNode
                newNode.setLink(prevNode);
            }

            // set prevNode to the newNode, then continue to next iteration
            prevNode = newNode;
        }

        // set the head
        this.head = prevNode;
    }

    /**
     * A re-implementation of the Integer.parseInt() static method.
     *
     * @param input
     *   The string to convert to an integer
     * @precondition
     *   String input contains one or more numeric digits
     */ 
    public static int parseInt(String input) {
        // sanitize input String

        // assume sign is positive
        int sign = 1;

        // check if negative sign at start of input, set sign accordingly
        if (input.charAt(0) == '-')
            sign = -1;

        // use regex to remove all non-digits from input
        // (no scientific notation, kthxbai)
        input = input.replaceAll("[^\\d]+", "");

        int len = input.length();

        // if the string is empty, then no digits were in the input
        if (len == 0)
            throw new NumberFormatException("String must contain one or more digits");

        char digit;
        int asciiCode;
        int pwr = 0;
        int num = 0;

        // loop through input string right-to-left (least significant digit to most significant)
        for (int i=len-1; i>-1; i--) {
            // get char digit at current position
            digit = input.charAt(i);
            // cast digit char as int to get ascii code
            asciiCode = (int)digit;

            // convert asciiCode to actual int digit, multiply digit by 10^(pwr), add to num
            num += UnboundedInt.asciiDigitLookup(asciiCode) * Math.pow(10, pwr++);
        }

        return sign*num;
    }

    /**
     * Lookup and return the numeric digit an asciiCode represents as an int.
     * Throw an IllegalArgumentException if the asciiCode input does not represent a numeric digit.
     *
     * @param asciiCode
     *   Primitive int representing the ASCII code to look up.
     * @precondition
     *   Input asciiCode is the code for a numeric digit [0-9], i.e. within range [48-57]
     * @return
     *   The digit the asciiCode input represents as an integer.
     * @exception IllegalArgumentException
     *   Thrown if the asciiCode input does not represent a numeric digit (code outside of range [48-57])
     */
    public static int asciiDigitLookup(int asciiCode) {
        // ascii code 48 = digit 0; ascii code 57 = digit 9
        // by subtracting the asciiCode input from 48, we get the exact int digit it represents
        int digit = asciiCode - 48;

        // make sure the digit is within bounds
        if (digit < 0 || digit > 9)
            throw new IllegalArgumentException("Ascii code "+ asciiCode +" does not correspond to a digit [0-9]");

        return digit;
    }

    /**
     * Loop through IntNodes and concatenate values together to form complete numeric string
     * representing the number encapsulated by this UnboundedInt.
     *
     * @param none
     * @return
     *   String containing number encapsulated by this UnboundedInt
     */
    public String toString() {
        IntNode curNode = this.head;
        String out = String.format("%d", curNode.getData());
        curNode = this.head.getLink();
        while (curNode) {
            // use String.format() to left-pad with zeros so length is always 3 digits
            out = out + String.format("%03d", curNode.getData());
        }

        if (sign == -1)
            out = "-" + out;

        return out;
    }

    public void start() {
        this.cursor = this.head;
    }

    public void advance() {
        if (this.cursor == null)
            throw new IllegalStateException("Cursor is null (not pointing to an IntNode)");

        this.cursor = this.cursor.getLink();
    }

    public int getNodeValue() {
        if (this.cursor == null)
            throw new IllegalStateException("Cursor is null (not pointing to an IntNode)");

        return this.cursor.getData();
    }

    public boolean equals(Object o) {
        if (o instanceof UnboundedInt) {
            UnboundedInt u = (UnboundedInt)o;
            if (String.equals(this.toString(), u.toString()))
                return true;
            return false;
        }
        return false;
    }

}